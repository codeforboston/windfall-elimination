"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const _require = require(`child_process`),
      execSync = _require.execSync;

const execa = require(`execa`);

const hostedGitInfo = require(`hosted-git-info`);

const fs = require(`fs-extra`);

const sysPath = require(`path`);

const report = require(`./reporter`);

const url = require(`url`);

const existsSync = require(`fs-exists-cached`).sync;

const _require2 = require(`gatsby-telemetry`),
      trackCli = _require2.trackCli,
      trackError = _require2.trackError;

const spawn = (cmd, options) => {
  const _cmd$split = cmd.split(/\s+/),
        file = _cmd$split[0],
        args = _cmd$split.slice(1);

  return execa(file, args, Object.assign({
    stdio: `inherit`
  }, options));
}; // Checks the existence of yarn package
// We use yarnpkg instead of yarn to avoid conflict with Hadoop yarn
// Refer to https://github.com/yarnpkg/yarn/issues/673
//
// Returns true if yarn exists, false otherwise


const shouldUseYarn = () => {
  try {
    execSync(`yarnpkg --version`, {
      stdio: `ignore`
    });
    return true;
  } catch (e) {
    return false;
  }
}; // Initialize newly cloned directory as a git repo


const gitInit =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (rootPath) {
    report.info(`Initialising git in ${rootPath}`);
    return yield spawn(`git init`, {
      cwd: rootPath
    });
  });

  return function gitInit(_x) {
    return _ref.apply(this, arguments);
  };
}(); // Create a .gitignore file if it is missing in the new directory


const maybeCreateGitIgnore =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    if (existsSync(sysPath.join(rootPath, `.gitignore`))) {
      return;
    }

    report.info(`Creating minimal .gitignore in ${rootPath}`);
    yield fs.writeFile(sysPath.join(rootPath, `.gitignore`), `.cache\nnode_modules\npublic\n`);
  });

  return function maybeCreateGitIgnore(_x2) {
    return _ref2.apply(this, arguments);
  };
}(); // Create an initial git commit in the new directory


const createInitialGitCommit =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (rootPath, starterUrl) {
    report.info(`Create initial git commit in ${rootPath}`);
    yield spawn(`git add -A`, {
      cwd: rootPath
    }); // use execSync instead of spawn to handle git clients using
    // pgp signatures (with password)

    execSync(`git commit -m "Initial commit from gatsby: (${starterUrl})"`, {
      cwd: rootPath
    });
  });

  return function createInitialGitCommit(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}(); // Executes `npm install` or `yarn install` in rootPath.


const install =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    const prevDir = process.cwd();
    report.info(`Installing packages...`);
    process.chdir(rootPath);

    try {
      let cmd = shouldUseYarn() ? spawn(`yarnpkg`) : spawn(`npm install`);
      yield cmd;
    } finally {
      process.chdir(prevDir);
    }
  });

  return function install(_x5) {
    return _ref4.apply(this, arguments);
  };
}();

const ignored = path => !/^\.(git|hg)$/.test(sysPath.basename(path)); // Copy starter from file system.


const copy =
/*#__PURE__*/
function () {
  var _ref5 = (0, _asyncToGenerator2.default)(function* (starterPath, rootPath) {
    // Chmod with 755.
    // 493 = parseInt('755', 8)
    yield fs.mkdirp(rootPath, {
      mode: 493
    });

    if (!existsSync(starterPath)) {
      throw new Error(`starter ${starterPath} doesn't exist`);
    }

    if (starterPath === `.`) {
      throw new Error(`You can't create a starter from the existing directory. If you want to
      create a new site in the current directory, the trailing dot isn't
      necessary. If you want to create a new site from a local starter, run
      something like "gatsby new new-gatsby-site ../my-gatsby-starter"`);
    }

    report.info(`Creating new site from local starter: ${starterPath}`);
    report.log(`Copying local starter to ${rootPath} ...`);
    yield fs.copy(starterPath, rootPath, {
      filter: ignored
    });
    report.success(`Created starter directory layout`);
    yield install(rootPath);
    return true;
  });

  return function copy(_x6, _x7) {
    return _ref5.apply(this, arguments);
  };
}(); // Clones starter from URI.


const clone =
/*#__PURE__*/
function () {
  var _ref6 = (0, _asyncToGenerator2.default)(function* (hostInfo, rootPath) {
    let url; // Let people use private repos accessed over SSH.

    if (hostInfo.getDefaultRepresentation() === `sshurl`) {
      url = hostInfo.ssh({
        noCommittish: true
      }); // Otherwise default to normal git syntax.
    } else {
      url = hostInfo.https({
        noCommittish: true,
        noGitPlus: true
      });
    }

    const branch = hostInfo.committish ? `-b ${hostInfo.committish}` : ``;
    report.info(`Creating new site from git: ${url}`);
    yield spawn(`git clone ${branch} ${url} ${rootPath} --single-branch`);
    report.success(`Created starter directory layout`);
    yield fs.remove(sysPath.join(rootPath, `.git`));
    yield install(rootPath);
    yield gitInit(rootPath);
    yield maybeCreateGitIgnore(rootPath);
    yield createInitialGitCommit(rootPath, url);
  });

  return function clone(_x8, _x9) {
    return _ref6.apply(this, arguments);
  };
}();

/**
 * Main function that clones or copies the starter.
 */
module.exports =
/*#__PURE__*/
function () {
  var _ref7 = (0, _asyncToGenerator2.default)(function* (starter, options = {}) {
    const rootPath = options.rootPath || process.cwd();
    const urlObject = url.parse(rootPath);

    if (urlObject.protocol && urlObject.host) {
      trackError(`NEW_PROJECT_NAME_MISSING`);
      report.panic(`It looks like you forgot to add a name for your new project. Try running instead "gatsby new new-gatsby-project ${rootPath}"`);
      return;
    }

    if (existsSync(sysPath.join(rootPath, `package.json`))) {
      trackError(`NEW_PROJECT_IS_NPM_PROJECT`);
      report.panic(`Directory ${rootPath} is already an npm project`);
      return;
    }

    const hostedInfo = hostedGitInfo.fromUrl(starter);
    trackCli(`NEW_PROJECT`, {
      starterName: starter
    });
    if (hostedInfo) yield clone(hostedInfo, rootPath);else yield copy(starter, rootPath);
  });

  return function (_x10) {
    return _ref7.apply(this, arguments);
  };
}();