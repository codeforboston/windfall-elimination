{"version":3,"sources":["../../../src/db/loki/nodes-query.js"],"names":["_","require","prepareRegex","getNodeTypeCollection","sift","emitter","fieldUsages","FIELD_INDEX_THRESHOLD","on","field","siftifyArgs","object","newObject","each","v","k","isPlainObject","Minimatch","mm","makeRe","runSift","nodes","query","siftQuery","$elemMatch","toMongoArgs","gqlFilter","lastFieldType","mongoArgs","obj","result","length","gqlFieldType","getFields","type","re","isUndefined","test","undefined","constructor","name","concat","toDottedFields","filter","acc","path","Object","keys","forEach","key","value","nextValue","join","isNeTrue","first","rest","fixNeTrue","reduce","split","convertArgs","gqlArgs","gqlType","toSortFields","sortArgs","fields","order","lokiSortFields","i","dottedField","isDesc","toLowerCase","push","ensureFieldIndexes","coll","lokiArgs","fieldName","update","n","get","ensureIndex","runQuery","queryArgs","firstOnly","JSON","parse","stringify","chain","find","sort","sortFields","sortField","compoundsort","data","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst prepareRegex = require(`../../utils/prepare-regex`)\nconst { getNodeTypeCollection } = require(`./nodes`)\nconst sift = require(`sift`)\nconst { emitter } = require(`../../redux`)\n\n// Cleared on DELETE_CACHE\nconst fieldUsages = {}\nconst FIELD_INDEX_THRESHOLD = 5\n\nemitter.on(`DELETE_CACHE`, () => {\n  for (var field in fieldUsages) {\n    delete fieldUsages[field]\n  }\n})\n\n// Takes a raw graphql filter and converts it into a mongo-like args\n// object that can be understood by the `sift` library. E.g `eq`\n// becomes `$eq`\nfunction siftifyArgs(object) {\n  const newObject = {}\n  _.each(object, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        k = `$elemMatch`\n      }\n      newObject[k] = siftifyArgs(v)\n    } else {\n      // Compile regex first.\n      if (k === `regex`) {\n        newObject[`$regex`] = prepareRegex(v)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        newObject[`$regex`] = mm.makeRe()\n      } else {\n        newObject[`$${k}`] = v\n      }\n    }\n  })\n  return newObject\n}\n\n// filter nodes using the `sift` library. But isn't this a loki query\n// file? Yes, but we need to support all functionality provided by\n// `run-sift`, and there are some operators that loki can't\n// support. Like `elemMatch`, so for those fields, we fall back to\n// sift\nfunction runSift(nodes, query) {\n  if (nodes) {\n    const siftQuery = {\n      $elemMatch: siftifyArgs(query),\n    }\n    return sift(siftQuery, nodes)\n  } else {\n    return null\n  }\n}\n\n// Takes a raw graphql filter and converts it into a mongo-like args\n// object that can be understood by loki. E.g `eq` becomes\n// `$eq`. gqlFilter should be the raw graphql filter returned from\n// graphql-js. e.g gqlFilter:\n//\n// {\n//   internal: {\n//     type: {\n//       eq: \"TestNode\"\n//     },\n//     content: {\n//       glob: \"et\"\n//     }\n//   },\n//   id: {\n//     glob: \"12*\"\n//   }\n// }\n//\n// would return\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"  // append $ to eq\n//     },\n//     content: {\n//       $regex: new MiniMatch(v) // convert glob to regex\n//     }\n//   },\n//   id: {\n//     $regex: // as above\n//   }\n// }\nfunction toMongoArgs(gqlFilter, lastFieldType) {\n  const mongoArgs = {}\n  _.each(gqlFilter, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        // loki doesn't support elemMatch, so use sift (see runSift\n        // comment above)\n        mongoArgs[`$where`] = obj => {\n          const result = runSift(obj, v)\n          return result && result.length > 0\n        }\n      } else {\n        const gqlFieldType = lastFieldType.getFields()[k].type\n        mongoArgs[k] = toMongoArgs(v, gqlFieldType)\n      }\n    } else {\n      if (k === `regex`) {\n        const re = prepareRegex(v)\n        // To ensure that false is returned if a field doesn't\n        // exist. E.g `{nested.field: {$regex: /.*/}}`\n        mongoArgs[`$where`] = obj => !_.isUndefined(obj) && re.test(obj)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        mongoArgs[`$regex`] = mm.makeRe()\n      } else if (k === `eq` && v === null) {\n        mongoArgs[`$in`] = [null, undefined]\n      } else if (\n        k === `eq` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$contains`] = v\n      } else if (\n        k === `ne` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsNone`] = v\n      } else if (\n        k === `in` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsAny`] = v\n      } else if (\n        k === `nin` &&\n        lastFieldType &&\n        lastFieldType.constructor.name === `GraphQLList`\n      ) {\n        mongoArgs[`$containsNone`] = v\n      } else if (k === `ne` && v === null) {\n        mongoArgs[`$ne`] = undefined\n      } else if (k === `nin` && lastFieldType.name === `Boolean`) {\n        mongoArgs[`$nin`] = v.concat([undefined])\n      } else {\n        mongoArgs[`$${k}`] = v\n      }\n    }\n  })\n  return mongoArgs\n}\n\n// Converts a nested mongo args object into a dotted notation. acc\n// (accumulator) must be a reference to an empty object. The converted\n// fields will be added to it. E.g\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"\n//     },\n//     content: {\n//       $regex: new MiniMatch(v)\n//     }\n//   },\n//   id: {\n//     $regex: newMiniMatch(v)\n//   }\n// }\n//\n// After execution, acc would be:\n//\n// {\n//   \"internal.type\": {\n//     $eq: \"TestNode\"\n//   },\n//   \"internal.content\": {\n//     $regex: new MiniMatch(v)\n//   },\n//   \"id\": {\n//     $regex: // as above\n//   }\n// }\nconst toDottedFields = (filter, acc = {}, path = []) => {\n  Object.keys(filter).forEach(key => {\n    const value = filter[key]\n    const nextValue = _.isPlainObject(value) && value[Object.keys(value)[0]]\n    if (_.isPlainObject(nextValue)) {\n      toDottedFields(value, acc, path.concat(key))\n    } else {\n      acc[path.concat(key).join(`.`)] = value\n    }\n  })\n  return acc\n}\n\n// The query language that Gatsby has used since day 1 is `sift`. Both\n// sift and loki are mongo-like query languages, but they have some\n// subtle differences. One is that in sift, a nested filter such as\n// `{foo: {bar: {ne: true} } }` will return true if the foo field\n// doesn't exist, is null, or bar is null. Whereas loki will return\n// false if the foo field doesn't exist or is null. This ensures that\n// loki queries behave like sift\nconst isNeTrue = (obj, path) => {\n  if (path.length) {\n    const [first, ...rest] = path\n    return obj == null || obj[first] == null || isNeTrue(obj[first], rest)\n  } else {\n    return obj !== true\n  }\n}\n\nconst fixNeTrue = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    const value = filter[key]\n    if (value[`$ne`] === true) {\n      const [first, ...path] = key.split(`.`)\n      acc[first] = { [`$where`]: obj => isNeTrue(obj, path) }\n    } else {\n      acc[key] = value\n    }\n    return acc\n  }, {})\n\n// Converts graphQL args to a loki filter\nconst convertArgs = (gqlArgs, gqlType) =>\n  fixNeTrue(toDottedFields(toMongoArgs(gqlArgs.filter, gqlType)))\n\n// Converts graphql Sort args into the form expected by loki, which is\n// a vector where the first value is a field name, and the second is a\n// boolean `isDesc`. Nested fields delimited by `___` are replaced by\n// periods. E.g\n//\n// {\n//   fields: [ `frontmatter___date`, `id` ],\n//   order: [`desc`]\n// }\n//\n// would return\n//\n// [ [ `frontmatter.date`, true ], [ `id`, false ] ]\n//\nfunction toSortFields(sortArgs) {\n  const { fields, order } = sortArgs\n  const lokiSortFields = []\n  for (let i = 0; i < fields.length; i++) {\n    const dottedField = fields[i]\n    const isDesc = order[i] && order[i].toLowerCase() === `desc`\n    lokiSortFields.push([dottedField, isDesc])\n  }\n  return lokiSortFields\n}\n\n// Every time we run a query, we increment a counter for each of its\n// fields, so that we can determine which fields are used the\n// most. Any time a field is seen more than `FIELD_INDEX_THRESHOLD`\n// times, we create a loki index so that future queries with that\n// field will execute faster.\nfunction ensureFieldIndexes(coll, lokiArgs) {\n  _.forEach(lokiArgs, (v, fieldName) => {\n    // Increment the usages of the field\n    _.update(fieldUsages, fieldName, n => (n ? n + 1 : 1))\n    // If we have crossed the threshold, then create the index\n    if (_.get(fieldUsages, fieldName) === FIELD_INDEX_THRESHOLD) {\n      // Loki ensures that this is a noop if index already exists. E.g\n      // if it was previously added via a sort field\n      coll.ensureIndex(fieldName)\n    }\n  })\n}\n\n/**\n * Runs the graphql query over the loki nodes db.\n *\n * @param {Object} args. Object with:\n *\n * {Object} gqlType: built during `./build-node-types.js`\n *\n * {Object} queryArgs: The raw graphql query as a js object. E.g `{\n * filter: { fields { slug: { eq: \"/somepath\" } } } }`\n *\n * {Object} context: The context from the QueryJob\n *\n * {boolean} firstOnly: Whether to return the first found match, or\n * all matching results\n *\n * @returns {promise} A promise that will eventually be resolved with\n * a collection of matching objects (even if `firstOnly` is true)\n */\nasync function runQuery({ gqlType, queryArgs, firstOnly }) {\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const gqlArgs = JSON.parse(JSON.stringify(queryArgs))\n  const lokiArgs = convertArgs(gqlArgs, gqlType)\n  const coll = getNodeTypeCollection(gqlType.name)\n  ensureFieldIndexes(coll, lokiArgs)\n  let chain = coll.chain().find(lokiArgs, firstOnly)\n\n  if (queryArgs.sort) {\n    const sortFields = toSortFields(queryArgs.sort)\n\n    // Create an index for each sort field. Indexing requires sorting\n    // so we lose nothing by ensuring an index is added for each sort\n    // field. Loki ensures this is a noop if the index already exists\n    for (const sortField of sortFields) {\n      coll.ensureIndex(sortField[0])\n    }\n    chain = chain.compoundsort(sortFields)\n  }\n\n  return chain.data()\n}\n\nmodule.exports = runQuery\n"],"file":"nodes-query.js"}